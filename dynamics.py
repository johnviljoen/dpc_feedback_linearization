import jax
import jax.numpy as jnp
import equinox as eqx
import geometry

# harcoded
g = 9.81

# THIS FUNCTIONS
# @eqx.filter_jit
# def f_fl(x, u, d, Ts, qp, cp): # L_p_w=0.05

#     """
#     parameters:
#         qp = quad parameters
#         cp = control parameters

#     state:
#         x = {x,y,z,q0,q1,q2,q3,xd,yd,zd,p ,q ,r ,w0,w1,w2,w3,ptx, pty, ptz}
#              0 1 2 3  4  5  6  7  8  9  10 11 12 13 14 15 16 17   18   19
#              p     q           v        omega    n           p_til_int 

#     control:
#         u = {p_dx,p_dy,p_dz,dp_dx,dp_dy,dp_dz,ddp_dx,ddp_dy,ddp_dz}
#              0   1    2
#              p desired      v desired         a desired

#     kwargs:

#         disturbance (simulated wind):
#             d = {velW,qW0,qW1}
#                  0    1   2

#         gravity: 9.81

#         rotors proportional control gain at Ts of 0.001s: K_p_w

#     inner loop controllers:

#         1. rotor actuation p control
#         2. feedback linearization with integral action thrust control
#         3. attitude p control
#     """

#     # inner loop for thrust feedback linearization control
#     # ----------------------------------------------------

#     # compute desired force f_d via feedback linearization
#     tilde_p = x[0:3] - u[0:3]
#     x = x.at[17:20].set(x[17:20] + tilde_p * Ts)
#     v_r = u[3:6] - 2 * cp["Lambda"] @ tilde_p - cp["Lambda"] @ cp["Lambda"] @ x[17:20]
#     dv_r = u[6:9] - 2 * cp["Lambda"] @ (x[7:10] - u[3:6]) - cp["Lambda"] @ cp["Lambda"] @ tilde_p
#     s = u[3:6] - v_r
#     hat_f_a = jnp.zeros(3) # Estimate interaction forces (assuming zero for single vehicle)
#     f_d = qp["mB"] * dv_r - cp["K"] @ s - qp["mB"] * jnp.array([0, 0, -g]) - hat_f_a

#     # inner loop for attitude control
#     # -------------------------------
#     T_d = jnp.linalg.norm(f_d)
#     b3_d = f_d / T_d
#     psi_d = 0.0 # Desired yaw angle (set to zero for simplicity)
#     a_yaw = jnp.array([jnp.cos(psi_d), jnp.sin(psi_d), 0])
#     b2_d = jnp.cross(b3_d, a_yaw)
#     b2_d /= jnp.linalg.norm(b2_d)
#     b1_d = jnp.cross(b2_d, b3_d)
#     R_d = jnp.column_stack((b1_d, b2_d, b3_d))

#     # edge case where we demand freefall - leading to undefined desired attitude
#     freefall_mask = jnp.linalg.norm(f_d) < qp["minThr"]
#     def freefall_case(_):
#         R_d = geometry.quaternion_to_rotation_matrix(x[3:7])
#         T_d = qp["minThr"]
#         return R_d, T_d
#     def regular_case(_):
#         return R_d, T_d
#     R_d, T_d = jax.lax.cond(freefall_mask, freefall_case, regular_case, operand=None)

#     R = geometry.quaternion_to_rotation_matrix(x[3:7])
#     e_R_matrix = 0.5 * (R_d.T @ R - R.T @ R_d)
#     vee_map = lambda S: jnp.array([S[2,1], S[0,2], S[1,0]])
#     e_R = vee_map(e_R_matrix)
#     e_omega = x[10:13]
#     tau_d = -cp["K_R"] @ e_R - cp["K_omega"] @ e_omega
#     eta_d = jnp.hstack([T_d, tau_d])
#     n_d = jnp.linalg.pinv(qp["B0"]) @ eta_d
#     n_d = jnp.clip(n_d, qp["minWmotor"]**2, qp["maxWmotor"]**2)
#     n_d = jnp.sqrt(n_d)

#     # inner loop for rotor speed control - assumes no drag on rotors
#     # --------------------------------------------------------------

#     # we change the ratio of the gain dependent on the used time-step to
#     # approximately achieve the same results regardless of timestep
#     K_p_w = 0.001 / Ts * cp["K_p_w"]

#     # P gain * error for rotors
#     tau = K_p_w * (n_d - x[13:17])

#     # instantaneous thrusts and torques generated by the current w0...w3
#     # x[13:17] = jnp.clip(x[13:17], qp["minWmotor"], qp["maxWmotor"]) # this clip shouldn't occur within the dynamics
#     th = qp['kTh'] * x[13:17] ** 2
#     to = qp['kTo'] * x[13:17] ** 2

#     # state derivates (from sympy.mechanics derivation)
#     # -------------------------------------------------
#     xd = jnp.stack(
#         [
#             x[7], x[8], x[9], # xd, yd, zd
#             - 0.5 * x[10] * x[4] - 0.5 * x[11] * x[5] - 0.5 * x[6] * x[12], # q0d
#               0.5 * x[10] * x[3] - 0.5 * x[11] * x[6] + 0.5 * x[5] * x[12], # q1d
#               0.5 * x[10] * x[6] + 0.5 * x[11] * x[3] - 0.5 * x[4] * x[12], # q2d
#             - 0.5 * x[10] * x[5] + 0.5 * x[11] * x[4] + 0.5 * x[3] * x[12], # q3d
#             - (
#                 qp["Cd"]
#                 * jnp.sign(d[0] * jnp.cos(d[1]) * jnp.cos(d[2]) - x[7])
#                 * (d[0] * jnp.cos(d[1]) * jnp.cos(d[2]) - x[7]) ** 2
#                 - 2 * (x[3] * x[5] + x[4] * x[6]) * (th[0] + th[1] + th[2] + th[3])
#             )
#             / qp["mB"], # xdd
#             - (
#                 qp["Cd"]
#                 * jnp.sign(d[0] * jnp.sin(d[1]) * jnp.cos(d[2]) - x[8])
#                 * (d[0] * jnp.sin(d[1]) * jnp.cos(d[2]) - x[8]) ** 2
#                 + 2 * (x[3] * x[4] - x[5] * x[6]) * (th[0] + th[1] + th[2] + th[3])
#             )
#             / qp["mB"], # ydd
#             - (
#                 -qp["Cd"] * jnp.sign(d[0] * jnp.sin(d[2]) + x[9]) * (d[0] * jnp.sin(d[2]) + x[9]) ** 2
#                 - (th[0] + th[1] + th[2] + th[3])
#                 * (x[3] ** 2 - x[4] ** 2 - x[5] ** 2 + x[6] ** 2)
#                 + g * qp["mB"]
#             )
#             / qp["mB"], # zdd (the - in front turns increased height to be positive - SWU)
#             (
#                 (qp["IB"][1,1] - qp["IB"][2,2]) * x[11] * x[12]
#                 - qp["usePrecession"] * qp["IRzz"] * (x[13] - x[14] + x[15] - x[16]) * x[11]
#                 + (th[0] - th[1] - th[2] + th[3]) * qp["dym"]
#             )
#             / qp["IB"][0,0], # pd
#             (
#                 (qp["IB"][2,2] - qp["IB"][0,0]) * x[10] * x[12]
#                 + qp["usePrecession"] * qp["IRzz"] * (x[13] - x[14] + x[15] - x[16]) * x[10]
#                 + (th[0] + th[1] - th[2] - th[3]) * qp["dxm"]
#             )
#             / qp["IB"][1,1], #qd
#             ((qp["IB"][0,0] - qp["IB"][1,1]) * x[10] * x[11] - to[0] + to[1] - to[2] + to[3]) / qp["IB"][2,2], # rd
#             tau[0] / qp["IRzz"], tau[1] / qp["IRzz"], tau[2] / qp["IRzz"], tau[3] / qp["IRzz"] # w0d ... w3d
#         ]
#     )

#     xnext = jnp.hstack([x[0:17] + xd * Ts, x[17:20]]) # we use the same integrator on p_tilde_int (x[17:20]) above
#     return xnext

# THIS FUNCTIONS
# @eqx.filter_jit
# def f_fl(x, u, d, Ts, qp, cp): # L_p_w=0.05

#     """
#     parameters:
#         qp = quad parameters
#         cp = control parameters

#     state:
#         x = {x,y,z,q0,q1,q2,q3,xd,yd,zd,p ,q ,r ,w0,w1,w2,w3,ptx, pty, ptz}
#              0 1 2 3  4  5  6  7  8  9  10 11 12 13 14 15 16 17   18   19
#              p     q           v        omega    n           p_til_int 

#     control:
#         u = {p_dx,p_dy,p_dz,dp_dx,dp_dy,dp_dz,ddp_dx,ddp_dy,ddp_dz}
#              0   1    2
#              p desired      v desired         a desired

#     kwargs:

#         disturbance (simulated wind):
#             d = {velW,qW0,qW1}
#                  0    1   2

#         gravity: 9.81

#         rotors proportional control gain at Ts of 0.001s: K_p_w

#     inner loop controllers:

#         1. rotor actuation p control
#         2. feedback linearization with integral action thrust control
#         3. attitude p control
#     """
#     # def step_fl_state(x, u, Ts):
#     #     x = x.at[17:20].set(x[17:20] + tilde_p * Ts)
#     #     return x
    

#     def calc_f_d(x, u, Ts, qp, cp):
#         # inner loop for thrust feedback linearization control
#         # ----------------------------------------------------

#         # compute desired force f_d via feedback linearization
#         tilde_p = x[0:3] - u[0:3]
#         v_r = u[3:6] - 2 * cp["Lambda"] @ tilde_p - cp["Lambda"] @ cp["Lambda"] @ x[17:20]
#         dv_r = u[6:9] - 2 * cp["Lambda"] @ (x[7:10] - u[3:6]) - cp["Lambda"] @ cp["Lambda"] @ tilde_p
#         s = u[3:6] - v_r
#         hat_f_a = jnp.zeros(3) # Estimate interaction forces (assuming zero for single vehicle)
#         f_d = qp["mB"] * dv_r - cp["K"] @ s - qp["mB"] * jnp.array([0, 0, -g]) - hat_f_a
#         return f_d

#     f_d = calc_f_d(x, u, Ts, qp, cp)

#     def calc_n_d(x, f_d, qp, cp):
#         # inner loop for attitude control
#         # -------------------------------
#         T_d = jnp.linalg.norm(f_d)
#         b3_d = f_d / T_d
#         psi_d = 0.0 # Desired yaw angle (set to zero for simplicity)
#         a_yaw = jnp.array([jnp.cos(psi_d), jnp.sin(psi_d), 0])
#         b2_d = jnp.cross(b3_d, a_yaw)
#         b2_d /= jnp.linalg.norm(b2_d)
#         b1_d = jnp.cross(b2_d, b3_d)
#         R_d = jnp.column_stack((b1_d, b2_d, b3_d))

#         # edge case where we demand freefall - leading to undefined desired attitude
#         freefall_mask = jnp.linalg.norm(f_d) < qp["minThr"]
#         def freefall_case(_):
#             R_d = geometry.quaternion_to_rotation_matrix(x[3:7])
#             T_d = qp["minThr"]
#             return R_d, T_d
#         def regular_case(_):
#             return R_d, T_d
#         R_d, T_d = jax.lax.cond(freefall_mask, freefall_case, regular_case, operand=None)

#         R = geometry.quaternion_to_rotation_matrix(x[3:7])
#         e_R_matrix = 0.5 * (R_d.T @ R - R.T @ R_d)
#         vee_map = lambda S: jnp.array([S[2,1], S[0,2], S[1,0]])
#         e_R = vee_map(e_R_matrix)
#         e_omega = x[10:13]
#         tau_d = -cp["K_R"] @ e_R - cp["K_omega"] @ e_omega
#         eta_d = jnp.hstack([T_d, tau_d])
#         n_d = jnp.linalg.pinv(qp["B0"]) @ eta_d
#         n_d = jnp.clip(n_d, qp["minWmotor"]**2, qp["maxWmotor"]**2)
#         n_d = jnp.sqrt(n_d)
#         return n_d

#     n_d = calc_n_d(x, f_d, qp, cp)

#     def calc_tau(x, n_d, cp):
#         # inner loop for rotor speed control - assumes no drag on rotors
#         # --------------------------------------------------------------

#         # we change the ratio of the gain dependent on the used time-step to
#         # approximately achieve the same results regardless of timestep
#         K_p_w = 0.001 / Ts * cp["K_p_w"]

#         # P gain * error for rotors
#         tau = K_p_w * (n_d - x[13:17])
#         return tau

#     tau = calc_tau(x, n_d, cp)

#     # instantaneous thrusts and torques generated by the current w0...w3
#     # x[13:17] = jnp.clip(x[13:17], qp["minWmotor"], qp["maxWmotor"]) # this clip shouldn't occur within the dynamics
#     th = qp['kTh'] * x[13:17] ** 2
#     to = qp['kTo'] * x[13:17] ** 2

#     # state derivates (from sympy.mechanics derivation)
#     # -------------------------------------------------
#     xd = jnp.stack(
#         [
#             x[7], x[8], x[9], # xd, yd, zd
#             - 0.5 * x[10] * x[4] - 0.5 * x[11] * x[5] - 0.5 * x[6] * x[12], # q0d
#               0.5 * x[10] * x[3] - 0.5 * x[11] * x[6] + 0.5 * x[5] * x[12], # q1d
#               0.5 * x[10] * x[6] + 0.5 * x[11] * x[3] - 0.5 * x[4] * x[12], # q2d
#             - 0.5 * x[10] * x[5] + 0.5 * x[11] * x[4] + 0.5 * x[3] * x[12], # q3d
#             - (
#                 qp["Cd"]
#                 * jnp.sign(d[0] * jnp.cos(d[1]) * jnp.cos(d[2]) - x[7])
#                 * (d[0] * jnp.cos(d[1]) * jnp.cos(d[2]) - x[7]) ** 2
#                 - 2 * (x[3] * x[5] + x[4] * x[6]) * (th[0] + th[1] + th[2] + th[3])
#             )
#             / qp["mB"], # xdd
#             - (
#                 qp["Cd"]
#                 * jnp.sign(d[0] * jnp.sin(d[1]) * jnp.cos(d[2]) - x[8])
#                 * (d[0] * jnp.sin(d[1]) * jnp.cos(d[2]) - x[8]) ** 2
#                 + 2 * (x[3] * x[4] - x[5] * x[6]) * (th[0] + th[1] + th[2] + th[3])
#             )
#             / qp["mB"], # ydd
#             - (
#                 -qp["Cd"] * jnp.sign(d[0] * jnp.sin(d[2]) + x[9]) * (d[0] * jnp.sin(d[2]) + x[9]) ** 2
#                 - (th[0] + th[1] + th[2] + th[3])
#                 * (x[3] ** 2 - x[4] ** 2 - x[5] ** 2 + x[6] ** 2)
#                 + g * qp["mB"]
#             )
#             / qp["mB"], # zdd (the - in front turns increased height to be positive - SWU)
#             (
#                 (qp["IB"][1,1] - qp["IB"][2,2]) * x[11] * x[12]
#                 - qp["usePrecession"] * qp["IRzz"] * (x[13] - x[14] + x[15] - x[16]) * x[11]
#                 + (th[0] - th[1] - th[2] + th[3]) * qp["dym"]
#             )
#             / qp["IB"][0,0], # pd
#             (
#                 (qp["IB"][2,2] - qp["IB"][0,0]) * x[10] * x[12]
#                 + qp["usePrecession"] * qp["IRzz"] * (x[13] - x[14] + x[15] - x[16]) * x[10]
#                 + (th[0] + th[1] - th[2] - th[3]) * qp["dxm"]
#             )
#             / qp["IB"][1,1], #qd
#             ((qp["IB"][0,0] - qp["IB"][1,1]) * x[10] * x[11] - to[0] + to[1] - to[2] + to[3]) / qp["IB"][2,2], # rd
#             tau[0] / qp["IRzz"], tau[1] / qp["IRzz"], tau[2] / qp["IRzz"], tau[3] / qp["IRzz"] # w0d ... w3d
#         ]
#     )

#     xd = jnp.hstack([xd, tilde_p])

#     xnext = x + xd * Ts

#     # xnext = jnp.hstack([x[0:17] + xd * Ts, x[17:20]]) # we use the same integrator on p_tilde_int (x[17:20]) above
#     return xnext

@eqx.filter_jit
def f_fl_patt_pr_step(x, u, d, qp, cp, Ts):
    # it is not so simple as to euler integrate the continuous time dynamics as the
    # quaternion orientation needs renormalization, the rotor speeds need clipping,
    # and (in my case) its helpful to warn if we are departing the predefined flight
    # envelope

    xd = f_fl_patt_pr(x, u, d, qp, cp)

    xnext = x + xd * Ts

    # normalize quaternion
    xnext = xnext.at[3:7].set(xnext[3:7] / jnp.linalg.norm(xnext[3:7]))

    # clip rotor speed
    xnext = xnext.at[13:17].set(jnp.clip(xnext[13:17], qp["x_lb"][13:17], qp["x_ub"][13:17]))

    # jax.debug.print("WARN: state outside flight envelope{}", )

    return xnext

@eqx.filter_jit
def f_fl_patt_pr(x, u, d, qp, cp):
    # f with feedback_linearization_thrust_p_attitude_p_rotor_control
    
    # compute desired force f_d via feedback linearization
    tilde_p = x[0:3] - u[0:3]
    v_r = u[3:6] - 2 * cp["Lambda"] @ tilde_p - cp["Lambda"] @ cp["Lambda"] @ x[17:20]
    dv_r = u[6:9] - 2 * cp["Lambda"] @ (x[7:10] - u[3:6]) - cp["Lambda"] @ cp["Lambda"] @ tilde_p
    s = u[3:6] - v_r
    hat_f_a = jnp.zeros(3) # Estimate interaction forces (assuming zero for single vehicle)
    f_d = qp["mB"] * dv_r - cp["K"] @ s - qp["mB"] * jnp.array([0, 0, -g]) - hat_f_a

    xd = jnp.hstack([f_patt_pr(x[0:17], f_d, d, qp, cp), tilde_p])
    # xnext = x + xd * Ts
    return xd

def f_patt_pr(x, f_d, d, qp, cp):

    T_d = jnp.linalg.norm(f_d)
    b3_d = f_d / T_d
    psi_d = 0.0 # Desired yaw angle (set to zero for simplicity)
    a_yaw = jnp.array([jnp.cos(psi_d), jnp.sin(psi_d), 0])
    b2_d = jnp.cross(b3_d, a_yaw)
    b2_d /= jnp.linalg.norm(b2_d)
    b1_d = jnp.cross(b2_d, b3_d)
    R_d = jnp.column_stack((b1_d, b2_d, b3_d))

    # edge case where we demand freefall - leading to undefined desired attitude
    freefall_mask = jnp.linalg.norm(f_d) < qp["minThr"]
    def freefall_case(_):
        R_d = geometry.quaternion_to_rotation_matrix(x[3:7])
        T_d = qp["minThr"]
        return R_d, T_d
    def regular_case(_):
        return R_d, T_d
    R_d, T_d = jax.lax.cond(freefall_mask, freefall_case, regular_case, operand=None)

    R = geometry.quaternion_to_rotation_matrix(x[3:7])
    e_R_matrix = 0.5 * (R_d.T @ R - R.T @ R_d)
    vee_map = lambda S: jnp.array([S[2,1], S[0,2], S[1,0]])
    e_R = vee_map(e_R_matrix)
    e_omega = x[10:13]
    tau_d = -cp["K_R"] @ e_R - cp["K_omega"] @ e_omega
    eta_d = jnp.hstack([T_d, tau_d])
    n_d = jnp.linalg.pinv(qp["B0"]) @ eta_d
    n_d = jnp.clip(n_d, qp["minWmotor"]**2, qp["maxWmotor"]**2)
    n_d = jnp.sqrt(n_d)

    xd = f_pr(x, n_d, d, qp, cp)

    return xd

def f_pr(x, n_d, d, qp, cp):

    # inner loop for rotor speed control - assumes no drag on rotors
    # --------------------------------------------------------------

    # we change the ratio of the gain dependent on the used time-step to
    # approximately achieve the same results regardless of timestep
    # K_p_w = 0.001 / Ts * cp["K_p_w"]

    # P gain * error for rotors
    tau = cp["K_p_w"] * (n_d - x[13:17])
    
    xd = f(x, tau, d, qp)
    return xd

def f(x, tau, d, qp):

    # instantaneous thrusts and torques generated by the current w0...w3
    # x[13:17] = jnp.clip(x[13:17], qp["minWmotor"], qp["maxWmotor"]) # this clip shouldn't occur within the dynamics
    th = qp['kTh'] * x[13:17] ** 2
    to = qp['kTo'] * x[13:17] ** 2

    # state derivates (from sympy.mechanics derivation)
    # -------------------------------------------------
    xd = jnp.stack(
        [
            x[7], x[8], x[9], # xd, yd, zd
            - 0.5 * x[10] * x[4] - 0.5 * x[11] * x[5] - 0.5 * x[6] * x[12], # q0d
              0.5 * x[10] * x[3] - 0.5 * x[11] * x[6] + 0.5 * x[5] * x[12], # q1d
              0.5 * x[10] * x[6] + 0.5 * x[11] * x[3] - 0.5 * x[4] * x[12], # q2d
            - 0.5 * x[10] * x[5] + 0.5 * x[11] * x[4] + 0.5 * x[3] * x[12], # q3d
            - (
                qp["Cd"]
                * jnp.sign(d[0] * jnp.cos(d[1]) * jnp.cos(d[2]) - x[7])
                * (d[0] * jnp.cos(d[1]) * jnp.cos(d[2]) - x[7]) ** 2
                - 2 * (x[3] * x[5] + x[4] * x[6]) * (th[0] + th[1] + th[2] + th[3])
            )
            / qp["mB"], # xdd
            - (
                qp["Cd"]
                * jnp.sign(d[0] * jnp.sin(d[1]) * jnp.cos(d[2]) - x[8])
                * (d[0] * jnp.sin(d[1]) * jnp.cos(d[2]) - x[8]) ** 2
                + 2 * (x[3] * x[4] - x[5] * x[6]) * (th[0] + th[1] + th[2] + th[3])
            )
            / qp["mB"], # ydd
            - (
                -qp["Cd"] * jnp.sign(d[0] * jnp.sin(d[2]) + x[9]) * (d[0] * jnp.sin(d[2]) + x[9]) ** 2
                - (th[0] + th[1] + th[2] + th[3])
                * (x[3] ** 2 - x[4] ** 2 - x[5] ** 2 + x[6] ** 2)
                + g * qp["mB"]
            )
            / qp["mB"], # zdd (the - in front turns increased height to be positive - SWU)
            (
                (qp["IB"][1,1] - qp["IB"][2,2]) * x[11] * x[12]
                - qp["usePrecession"] * qp["IRzz"] * (x[13] - x[14] + x[15] - x[16]) * x[11]
                + (th[0] - th[1] - th[2] + th[3]) * qp["dym"]
            )
            / qp["IB"][0,0], # pd
            (
                (qp["IB"][2,2] - qp["IB"][0,0]) * x[10] * x[12]
                + qp["usePrecession"] * qp["IRzz"] * (x[13] - x[14] + x[15] - x[16]) * x[10]
                + (th[0] + th[1] - th[2] - th[3]) * qp["dxm"]
            )
            / qp["IB"][1,1], #qd
            ((qp["IB"][0,0] - qp["IB"][1,1]) * x[10] * x[11] - to[0] + to[1] - to[2] + to[3]) / qp["IB"][2,2], # rd
            tau[0] / qp["IRzz"], tau[1] / qp["IRzz"], tau[2] / qp["IRzz"], tau[3] / qp["IRzz"] # w0d ... w3d
        ]
    )

    return xd

if __name__ == "__main__":

    from params import quad_params as qp

    x = jnp.array([0,0,0,1,0,0,0,0,0,0,0,0,0,*[522.9847140714692]*4])
    u = jnp.array([0.01,-0.01,0.01,-0.01])
    xd = f(qp, x, u)

    print('fin')